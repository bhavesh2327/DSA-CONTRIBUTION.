## üìå Problem Statement  
You are given a weighted, undirected graph with `n` nodes (0 to n-1) and a list of edges `roads`, where each road is defined as: 


## üí° Example  

**Input**:
n = 7
roads = [
[0,6,7], [0,1,2], [1,2,3], [1,3,3], [6,3,3],
[3,5,1], [6,5,1], [2,5,1], [0,4,5], [4,6,2]
]

**Output**:
4


Explanation: There are **4 shortest paths** from node 0 to node 6.

---

## ‚öôÔ∏è Approach  

We use **Dijkstra‚Äôs Algorithm** with a small modification:  

- Maintain `dist[i]` = shortest distance to node `i`.  
- Maintain `ways[i]` = number of shortest paths to node `i`.  

Steps:  
1. Build adjacency list from `roads`.  
2. Run Dijkstra from node `0`.  
3. While relaxing edges:
   - If a **shorter path** is found ‚Üí update distance and set `ways[v] = ways[u]`.  
   - If an **equal path** is found ‚Üí increment `ways[v] += ways[u]`.  
4. Answer = `ways[n-1]`.  

Time Complexity: **O(E log V)**  
Space Complexity: **O(V + E)**  

---

## üñ•Ô∏è Code  

class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
    vector<vector<pair<int,int>>> adj(n);
    for(auto &r : roads) {
        int u = r[0] , v = r[1] , w = r[2];
        adj[u].push_back({v,w});
        adj[v].push_back({u,w});
    }
    vector<long long> dist(n,LLONG_MAX);
    vector<int> ways(n,0);
    int MOD = 1e9 + 7;
    
    priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> pq;
    dist[0] = 0;
    ways[0] = 1;
    pq.push({0,0});
    while (!pq.empty()) {
        auto [d,u] = pq.top();
        pq.pop();
        if(d > dist[u]) continue;
        for(auto[v,w] : adj[u]){
                if(dist[u] + w < dist[v]){
                    dist[v] = dist[u] + w;
                    ways[v] = ways[u];
                    pq.push({dist[v],v});
                }
                else if (dist[u] + w == dist[v]){
                    ways[v] = (ways[v] + ways[u]) % MOD;
                }
            }
        }
    return ways[n-1];
    
    
}
};




